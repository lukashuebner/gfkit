#pragma once

#include <string>
#include <typeinfo>

#include <kassert/kassert.hpp>
#include <xxhash.h>

#include "sfkit/assertion_levels.hpp"
#include "sfkit/checking_casts.hpp"
#include "sfkit/utils/xxhash.hpp"

#define SFKIT_XXHASH_SUBTREE_IDS

#ifdef SFKIT_XXHASH_SUBTREE_IDS
using SubtreeHash                           = XXH128_hash_t;
constexpr SubtreeHash SuccinctSubtreeIdZero = {0, 0};

inline SubtreeHash& operator^=(SubtreeHash& lhs, SubtreeHash const& rhs) {
    lhs.low64 ^= rhs.low64;
    lhs.high64 ^= rhs.high64;
    return lhs;
}

class SubtreeHasher {
public:
    SubtreeHasher(XXH64_hash_t const& seed = 42) : _seed(seed) {
        reset();
    }

    template <typename T>
    requires requires(T const& t, XXH64_hash_t const& seed) {
        xxhash128(t, seed);
    }
    SubtreeHash hash_sample(T const& data) {
        return xxhash128(data, _seed);
    }

    void append_child(XXH128_hash_t const& data) {
        _data ^= data;
    }

    SubtreeHash hash() {
        // TODO Instead of a full hash, maybe use only the hash's finisher. The values are random anyhow, as
        // they were generated by xor-ing the hashes of the children.
        return xxhash128(_data, _seed);
    }

    void reset() {
        _data = SuccinctSubtreeIdZero;
    }

private:
    XXH64_hash_t const _seed;
    XXH128_hash_t      _data;
};

// SubtreeHash already is a hash; this function thus is the identity.
// Note however, that the value will get truncated.
template <>
struct std::hash<SubtreeHash> {
    size_t operator()(SubtreeHash const& subtree_id) const noexcept {
        return *(reinterpret_cast<size_t const*>(&subtree_id));
    }
};

#endif
